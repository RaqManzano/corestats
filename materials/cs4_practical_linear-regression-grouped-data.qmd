---
title: "Linear regression with grouped data"
---

```{r}
#| echo: false
#| message: false
#| results: hide
source(file = "setup_files/setup.R")
```

```{python}
#| echo: false
#| message: false
exec(open('setup_files/setup.py').read())
```

::: callout-tip
## Learning outcomes

**Questions**

- How do I perform a linear regression on grouped data?

**Objectives**

- Be able to perform a linear regression on grouped data in R
- Calculate the linear regression for individual groups and visualise these with the data
- Understand and be able to create equations of the regression line
- Be able to deal with interactions in this context
:::

## Libraries and functions

::: {.callout-note collapse="true"}
## Click to expand

::: {.panel-tabset group="language"}
## tidyverse

### Libraries

```{r}
#| eval: false
# A collection of R packages designed for data science
library(tidyverse)

# Converts stats functions to a tidyverse-friendly format
library(rstatix)

# Creates diagnostic plots using ggplot2
library(ggResidpanel)

# Helper functions for tidying data
library(broom)
```

### Functions

```{r}
#| eval: false
#| warning: false

# Gets underlying data out of model object
broom::augment()

# Creates diagnostic plots
ggResidpanel::resid_panel()
```

## R

### Functions

```{r}
#| eval: false
#| warning: false
# Creates a subset of the data
subset()
```


## Python
:::
:::

## Purpose and aim
A linear regression analysis with grouped data is used when we have one categorical predictor variable (or factor), and one continuous predictor variable. The response variable must still be continuous however.

For example in an experiment that looks at light intensity in woodland, how is light intensity (continuous: lux) affected by the height at which the measurement is taken, recorded as depth measured from the top of the canopy (continuous: metres) and by the type of woodland (categorical: Conifer or Broad leaf).

```{r, echo=FALSE, warning=FALSE, message=FALSE, show_col_types = FALSE}
read_csv("data/CS4-treelight.csv") %>% 
  ggplot(aes(x = depth, y = light, colour = species)) +
  geom_point() +
  scale_color_brewer(palette = "Dark2") +
  labs(x = "Depth (m)",
       y = "Light intensity (lux)")
```

When analysing these type of data we want to know:

1.	Is there a difference between the groups?
2.	Does the continuous predictor variable affect the continuous response variable (does canopy depth affect measured light intensity?)
3.	Is there any interaction between the two predictor variables? Here an interaction would display itself as a difference in the slopes of the regression lines for each group, so for example perhaps the conifer data set has a significantly steeper line than the broad leaf woodland data set.

In this case, no interaction means that the regression lines will have the same slope.
Essentially the analysis is identical to two-way ANOVA.

1. We will plot the data and visually inspect it.
2. We will test for an interaction and if it doesn’t exist then:
    a. We can test to see if either predictor variable has an effect (i.e. do the regression lines have different intercepts? and is the common gradient significantly different from zero?)
    
We will first consider how to visualise the data before then carrying out an appropriate statistical test.

## Data and hypotheses
The data are stored in `data/CS4-treelight.csv`. This is a data frame with four variables; `id`, `light`, `depth` and `species`. `light` is the continuous response variable, `depth` is the continuous predictor variable and `species` is the categorical predictor variable.

Read in the data and inspect them:

::: {.panel-tabset group="language"}
## tidyverse

```{r}
#| message: false
#| warning: false
# read in the data
treelight <- read_csv("data/CS4-treelight.csv")

# inspect the data
treelight
```

## R
```{r}
# read in the data
treelight_r <- read.csv("data/CS4-treelight.csv")

# inspect the data
head(treelight_r)
```

## Python

```{python}
# load the data
treelight_py = pd.read_csv("data/CS4-treelight.csv")

# and have a look
treelight_py.head()
```
:::

## Summarise and visualise

::: {.panel-tabset group="language"}
## tidyverse

```{r}
# plot the data
treelight %>% 
  ggplot(aes(x = depth, y = light, colour = species)) +
  geom_point() +
  scale_color_brewer(palette = "Dark2") +
  labs(x = "Depth (m)",
       y = "Light intensity (lux)")
```

## R

```{r}
plot(light ~ depth,
     data = treelight_r)
```

This plots all of the points in the data set on the same window. To visualise the data by `species`, we can use the `col` argument. This only takes data in the form of factors (categorical variables with inherit order), so we need to temporarily conver the `species` column to a factor with `col = factor(species)`:

```{r}
plot(light ~ depth,
     data = treelight_r,
     col = factor(species))
```

## Python

```{python}
#| results: hide
# plot the data
(
  ggplot(treelight_py,
    aes(x = "depth", y = "light", colour = "species")) +
    geom_point() +
    scale_color_brewer(type = "qual", palette = "Dark2") +
    labs(x = "Depth (m)",
         y = "Light intensity (lux)")
)
```

:::

It looks like there is a slight negative correlation between depth and light intensity, with light intensity reducing as the canopy depth increases. It would be useful to plot the regression lines in this plot.

::: {.panel-tabset group="language"}
## tidyverse

```{r}
#| message: false
# plot the data
treelight %>% 
  ggplot(aes(x = depth, y = light, colour = species)) +
  geom_point() +
  # add regression lines
  geom_smooth(method = "lm", se = FALSE) +
  scale_color_brewer(palette = "Dark2") +
  labs(x = "Depth (m)",
       y = "Light intensity (lux)")
```

## R

Unfortunately there is not an easy way in base R to add regression line to individual groups. To do this, we need to do three things:

1. Split the data by `species`
2. Create a linear model for each group
3. Determine the regression line (or line of best fit) for each group and then add this to the plot

The `subset` function creates subsets of data frames. The first argument is the original data frame, and the subset argument is a logical expression that defines which observations (rows) should be extracted. The logical expression must be enclosed in parentheses. In the first case it says (`Species == "Conifer"`). This tells R to only extract the rows of the original data frame which have `Conifer` in the species variable column. Ditto for `Broadleaf`.

First, we subset the data:
```{r}
# subset the conifers
conLight <- subset(treelight_r,
                   subset = (species == "Conifer"))

# subset the broad leaf
broLight <- subset(treelight_r,
                   subset = (species == "Broadleaf"))
```

Then we create a linear model for each subgroup:
```{r}
# linear regression for Broadleaf
lm_broadleaf <- lm(light ~ depth,
                   data = broLight)

# linear regression for Conifer
lm_conifer <- lm(light ~ depth,
                 data = conLight)
```

And plot it all together:
```{r}
plot(light ~ depth,
     data = treelight_r,
     col = factor(species))

# add the Broadleaf linear regression
abline(lm_broadleaf, col = "black")

# add the Conifer linear regression
abline(lm_conifer, col = "red")
```

## Python
```{python}
#| results: hide
# plot the data
(
ggplot(treelight_py,
       aes(x = "depth", y = "light", colour = "species")) +
  geom_point() +
  # add regression lines
  geom_smooth(method = "lm", se = False) +
  scale_color_brewer(type = "qual", palette = "Dark2") +
  labs(x = "Depth (m)",
       y = "Light intensity (lux)")
)
```
:::

Looking at this plot, there doesn’t appear to be any significant interaction between the woodland type (`Broadleaf` and `Conifer`) and the depth at which light measurements were taken (`depth`) on the amount of light intensity getting through the canopy as the gradients of the two lines appear to be very similar. There does appear to be a noticeable slope to both lines and both lines look as though they have very different intercepts. All of this suggests that there isn’t any interaction but that both `depth` and `species` have a significant effect on `light` independently.

## Implement and interpret the test
In this case we're going to implement the test before checking the assumptions (I know, let's live a little!). You'll find out why soon...

We can test for a possible interaction more formally:

::: {.panel-tabset group="language"}
## tidyverse

```{r}
anova(lm(light ~ depth * species,
         data = treelight))
```

Remember that `depth * species` is a shorthand way of writing the full set of `depth + species + depth:species` terms in R _i.e._ both main effects and the interaction effect.

## R

```{r}
anova(lm(light ~ depth * species,
         data = treelight))
```

Remember that `depth * species` is a shorthand way of writing the full set of `depth + species + depth:species` terms in R _i.e._ both main effects and the interaction effect.

## Python

Unfortunately there is no clear way of defining interaction models in pingouin. So we're resorting back to `statsmodels`, just like we had to when we performed the Shapiro-Wilk test on the residuals.

If you haven't loaded `statsmodels` yet, run the following:

```{python}
#| eval: false
import statsmodels.api as sm
import statsmodels.formula.api as smf
```

Next, we create a linear model and get the `.fit()`:

```{python}
# create a linear model
model = smf.ols(formula = "light ~ depth * C(species)",
                data = treelight_py)

# and get the fitted parameters of the model
lm_treelight_py = model.fit()
```

To get the relevant values, we can print the summary of the model fit. This gives us a rather huge table. Don't be too daunted by it - there is a logic to the madness and for now we're mainly interested in the `P>|t|` column.

```{python}
print(lm_treelight_py.summary())
```

:::

As with two-way ANOVA we have a row in the table for each of the different effects. At this point we are particularly interested in the p-values. We need to look at the interaction first.

The interaction term between `depth` and `species` has a p-value of 0.393 (which is bigger than 0.05) and so we can conclude that the interaction between `depth` and `species` isn’t significant. As such we can now consider whether each of the predictor variables independently has an effect.

Both `depth` and `species` have very small p-values (2.86x10<sup>-9</sup> and 4.13x10 <sup>-11</sup>) and so we can conclude that they do have a significant effect on `light`.

This means that the two regression lines should have the same non-zero slope, but different intercepts. We would now like to know what those values are.

### Finding intercept values

Finding the intercept values is not entirely straightforward and there is some deciphering required to get this right.

For a simple straight line such as the linear regression for the conifer data by itself, the output is relatively straightforward:

::: {.panel-tabset group="language"}
## tidyverse

```{r}
# filter the Conifer data and fit a linear model
treelight %>% 
  filter(species == "Conifer") %>% 
  lm(light ~ depth, data = .)
```

## R

```{r}
lm(light ~ depth,
   data = conLight)
```
## Python

We have two options to obtain the intercept for conifers only. We could subset our data, keeping only the conifer values. We could then create a linear model of those data, and obtain the relevant intercept.

However, since we already created a model for the entire data set (including the interaction term) and printed the summary of that, we can actually derive the intercept value with the information that we've got.

In the `coef` table of the summary there are several values:

```
Intercept                      7798.5655
C(species)[T.Conifer]         -2784.5833
depth                         -221.1256
depth:C(species)[T.Conifer]   -71.0357
```

This tells us that the _overall_ intercept value for the model with the interaction term is 7798.5655. The `C(species)[T.Conifer]` term means that, to go from this overall intercept value _to the intercept for conifer_, we need to add -2784.5833.

Doing the maths gives us an intercept of $7798.5655 + (-2784.5833) = 5014$ if we round this.

Equally, if we want to get the coefficient for `depth`, then we take the reference value of -221.1256 and add the value next to `depth:C(species)[T.Conifer]` to it. This gives us $-221.1256 + (-71.0357) = -292.2$ if we round it.

:::

We can interpret this as meaning that the intercept of the regression line is 5014 and the coefficient of the depth variable (the number in front of it in the equation) is -292.2.

So, the equation of the regression line for the conifer data is given by:

\begin{equation}
light = 5014 + -292.2 \times depth
\end{equation} 

This means that for every extra 1 m of depth of forest canopy we lose 292.2 lux of light.

When we looked at the full data set, we found that interaction wasn’t important. This means that we will have a model with two distinct intercepts but only a single slope (that’s what you get for a linear regression without any interaction), so we need to calculate that specific combination. We do this is as follows:

::: {.panel-tabset group="language"}
## tidyverse

```{r}
lm(light ~ depth + species,
   data = treelight)
```

Notice the `+` symbol in the argument, as opposed to the `*` symbol used earlier. This means that we are explicitly _not_ including an interaction term in this fit, and consequently we are forcing R to calculate the equation of lines which have the same gradient.

Ideally we would like R to give us two equations, one for each forest type, so four parameters in total.
Unfortunately, R is parsimonious and doesn’t do that. Instead R gives you three coefficients, and these require a bit of interpretation.

The first two numbers that R returns (underneath `Intercept` and `depth`) are the exact intercept and slope coefficients for one of the lines (in this case they correspond to the data for `Broadleaf` woodlands).

For the coefficients belonging to the other line, R uses these first two coefficients as baseline values and expresses the other coefficients relative to these ones. R also doesn’t tell you explicitly which group it is using as its baseline reference group! (Did I mention that R can be very helpful at times 😉?)

So, how to decipher the above output?

First, I need to work out which group has been used as the baseline.

* It will be the group that comes first alphabetically, so it should be `Broadleaf`
* The other way to check would be to look and see which group is not mentioned in the above table. `Conifer` is mentioned (in the `SpeciesConifer` heading) and so again the baseline group is `Broadleaf.`

This means that the intercept value and `depth` coefficient correspond to the `Broadleaf` group and as a result I know what the equation of one of my lines is:

Broadleaf:

\begin{equation}
light = 7962 + -262.2 \times depth
\end{equation} 

In this example we know that the gradient is the same for both lines (because we explicitly asked to exclude an interaction), so all I need to do is find the intercept value for the `Conifer` group. Unfortunately, the final value given underneath `SpeciesConifer` does not give me the intercept for `Conifer`, instead it tells me the difference between the `Conifer` group intercept and the baseline intercept i.e. the equation for the regression line for conifer woodland is given by:

\begin{equation}
light = (7962 + -3113) + -262.2 \times depth
\end{equation} 

\begin{equation}
light = 4829 + -262.2 \times depth
\end{equation} 

## R

```{r}
lm(light ~ depth + species,
   data = treelight_r)
```

Notice the `+` symbol in the argument, as opposed to the `*` symbol used earlier. This means that we are explicitly _not_ including an interaction term in this fit, and consequently we are forcing R to calculate the equation of lines which have the same gradient.

Ideally we would like R to give us two equations, one for each forest type, so four parameters in total.
Unfortunately, R is parsimonious and doesn’t do that. Instead R gives you three coefficients, and these require a bit of interpretation.

The first two numbers that R returns (underneath `Intercept` and `depth`) are the exact intercept and slope coefficients for one of the lines (in this case they correspond to the data for `Broadleaf` woodlands).

For the coefficients belonging to the other line, R uses these first two coefficients as baseline values and expresses the other coefficients relative to these ones. R also doesn’t tell you explicitly which group it is using as its baseline reference group! (Did I mention that R can be very helpful at times 😉?)

So, how to decipher the above output?

First, I need to work out which group has been used as the baseline.

* It will be the group that comes first alphabetically, so it should be `Broadleaf`
* The other way to check would be to look and see which group is not mentioned in the above table. `Conifer` is mentioned (in the `SpeciesConifer` heading) and so again the baseline group is `Broadleaf.`

This means that the intercept value and `depth` coefficient correspond to the `Broadleaf` group and as a result I know what the equation of one of my lines is:

Broadleaf:

\begin{equation}
light = 7962 + -262.2 \times depth
\end{equation} 

In this example we know that the gradient is the same for both lines (because we explicitly asked to exclude an interaction), so all I need to do is find the intercept value for the `Conifer` group. Unfortunately, the final value given underneath `SpeciesConifer` does not give me the intercept for `Conifer`, instead it tells me the difference between the `Conifer` group intercept and the baseline intercept i.e. the equation for the regression line for conifer woodland is given by:

\begin{equation}
light = (7962 + -3113) + -262.2 \times depth
\end{equation} 

\begin{equation}
light = 4829 + -262.2 \times depth
\end{equation} 

## Python

The way we obtain the values for the model without the interaction is very similar to what we did for the conifer data. We need to update our model first, to remove the interaction:

```{python}
# create a linear model
model = smf.ols(formula = "light ~ depth + C(species)",
                data = treelight_py)

# and get the fitted parameters of the model
lm_treelight_add_py = model.fit()
```

Notice the `+` symbol in the argument, as opposed to the `*` symbol used earlier. This means that we are explicitly _not_ including an interaction term in this fit, and consequently we are forcing Python to calculate the equation of lines which have the same gradient.

We can get the relevant coefficients as follows:

```{python}
print(lm_treelight_add_py.summary())
```

Again, I need to work out which group has been used as the baseline.

* It will be the group that comes first alphabetically, so it should be `Broadleaf`
* The other way to check would be to look and see which group is not mentioned in the above table. `Conifer` is mentioned (in the `C(species)[T.Conifer]` heading) and so again the baseline group is `Broadleaf.`

This means that the intercept value and `depth` coefficient correspond to the `Broadleaf` group and as a result I know what the equation of one of my lines is:

Broadleaf:

\begin{equation}
light = 7962 + -262.2 \times depth
\end{equation} 

In this example we know that the gradient is the same for both lines (because we explicitly asked to exclude an interaction), so all I need to do is find the intercept value for the `Conifer` group. Unfortunately, the final value given in `C(species)[T.Conifer]` does not give me the intercept for `Conifer`, instead it tells me the difference between the `Conifer` group intercept and the baseline intercept i.e. the equation for the regression line for conifer woodland is given by:

\begin{equation}
light = (7962 + -3113) + -262.2 \times depth
\end{equation} 

\begin{equation}
light = 4829 + -262.2 \times depth
\end{equation} 
:::

### Adding custom regression lines
In the example above we determined that the interaction term `species:depth` was not significant. It would be good to visualise the model without the interaction term.

::: {.panel-tabset group="language"}
## tidyverse
This is relatively straightforward if we understand the output of the model a bit better.

First of all, we load the `broom` library. This is part of tidyverse, so you don't have to install it. It is not loaded by default, hence us loading it. What broom does it changes the format of many common base R outputs into a more tidy format, so we can work with the output in our analyses more easily.

The function we use here is called `augment()`. What this does is take a model object and a dataset and adds information about each observation in the dataset.

```{r}
# define the model without interaction term
lm_additive <- lm(light ~ species + depth,
                  data = treelight)

# load the broom package
library(broom)

# augment the model
lm_additive %>% augment()
```

The output shows us lots of data. Our original `light` values are in the `light` column and it's the same for `species` and `depth`. What has been added is information about the fitted (or predicted) values based on the `light ~ depth + species` model we defined.

The fitted or predicted values are in the `.fitted` column, with corresponding residuals in the `.resid` column. Remember, your data = predicted values + error, so if you would add `.fitted` + `resid` then you would end up with your original data again.

Using this information we can now plot the regression lines by `species`:

```{r}
# plot the regression lines by species
lm_additive %>%
  augment() %>% 
  ggplot(aes(x = depth, y = .fitted, colour = species)) +
  geom_line() +
  scale_color_brewer(palette = "Dark2")
  
```

Lastly, if we would want to plot the data and regression lines together, we could change the code as follows:

```{r}
# plot the regression lines
lm_additive %>%
  augment() %>% 
  ggplot(aes(x = depth, y = .fitted, colour = species)) +
  # add the original data points
  geom_point(data = treelight,
             aes(x = depth, y = light, colour = species)) +
  geom_line() +
  scale_color_brewer(palette = "Dark2") +
  labs(x = "Depth (m)",
       y = "Light intensity (lux)")
```

## R
Unfortunately, base R doesn’t have a sensible way of automatically adding multiple regression lines to a plot and so if we want to do this, we will have to do it manually.

First, we create a linear regression without the interaction term.

```{r}
lm_treelight_r_add <- lm(light ~ depth + species,
             data = treelight_r)
```

We first need to extract the relative coefficient values from the `lm` object and then combine them manually to create separate vectors containing the intercept and slope coefficients for each line. This next set of command is a bit annoying but stick with it; it’ll pay dividends (no, really it will – you always secretly wanted to be a computer programmer didn’t you? This medic/biologist/life scientist thing is just a passing phase that you’ll grow out of…)

```{r}
cf <- coef(lm_treelight_r_add)
cf

cf_Broadleaf <- c(cf[1], cf[2])
cf_Conifer <- c(cf[1] + cf[3], cf[2])

cf_Broadleaf
cf_Conifer
```

* The first line extracts the three (in this case) coefficients from the `lm` object as a vector called `cf`, and the second line prints this to the screen.
* In the third line we take the 1st and 2nd components of `cf` and store them as the coefficients for the `Broadleaf` line in a vector called `cf_Broadleaf`
* The fourth line is where we do some actual calculations. Here we realise that the intercept of the conifer line is actually the sum of the 1st and 3rd values of `cf`, whereas the slope is just the 2nd value, and so we create a vector for the conifer line that reflects this.
* The 5th and 6th lines just print these two vectors to the screen.

We can now use these two vectors to add the appropriate regression lines to the plot with the original data. We've created _that_ particular plot before, so we can copy/paste the code.

```{r}
# plot original data
plot(light ~ depth,
     data = treelight_r,
     col = factor(species))

# add the Broadleaf regression line
abline(cf_Broadleaf, col = "black")

# add the Conifer regression line
abline(cf_Conifer, col = "red")
```

## Python
To do this, we need to do the following:

* create a linear model _without_ the interaction term (we did this previously)
* extract the predicted values of the model
* plot these against the original data

```{python}
# get predicted values
lm_treelight_add_py.predict()
```

We can't easily use the predicted values in this kind of format, so we're adding them to the existing data, in a column called `.fitted`:

```{python}
# add predicted values to data set
treelight_py['.fitted'] = lm_treelight_add_py.predict()

# have a peek at the data
treelight_py.head()
```

Now we can simply plot the data:

```{python}
#| results: hide
# plot the data
(
  ggplot(treelight_py,
    aes(x = "depth", y = "light", colour = "species")) +
    geom_point() +
    # add regression lines
    geom_line(aes(x = "depth", y = ".fitted", colour = "species")) +
    scale_color_brewer(type = "qual", palette = "Dark2") +
    labs(x = "Depth (m)",
         y = "Light intensity (lux)")
)
```
:::

## Assumptions
In this case we first wanted to check if the interaction was significant, prior to checking the assumptions. If we would have checked the assumptions first, then we would have done that one the full model (with the interaction), then done the ANOVA if everything was OK. We would have then found out that the interaction was not significant, meaning we'd have to re-check the assumptions with the new model. In what order you do it is a bit less important here. The main thing is that you check the assumptions and report on it!

Anyway, hopefully you’ve got the gist of checking assumptions for linear models by now: diagnostic plots!

::: {.panel-tabset group="language"}
## tidyverse

```{r}
#| message: false
lm_additive %>% 
  resid_panel(plots = c("resid", "qq", "ls", "cookd"),
              smoother = TRUE)
```

* The **Residuals plot** looks OK, no systematic pattern.
* The **Q-Q plot** isn’t perfect, but I’m happy with the normality assumption.
* The **Location-Scale plot** is OK, some very slight suggestion of heterogeneity of variance, but nothing to be too worried about.
* The **Cook's D plot** shows that all of the points are OK

## R

```{r}
par(mfrow = c(2, 2))
plot(lm(light ~ depth + species,
        data = treelight_r))
```

* The top left graph looks OK, no systematic pattern.
* The top right graph isn’t perfect, but I’m happy with the normality assumption.
* The bottom left graph is OK, some very slight suggestion of heterogeneity of variance, but nothing to be too worried about.
* The bottom right graph shows that all of the points are OK

## Python

```{python}
#| eval: false
dgplots(lm_treelight_add_py)
```

```{python}
#| echo: false
# load dgplots function for knitr
exec(open('setup_files/dgplots_knitr.py').read())
# create rendered diagnostic plots image
# and save the file link
dgplot = dgplotsknitr(lm_treelight_add_py)
```

```{r}
library(reticulate)
#| echo: false
# display image
knitr::include_graphics(py$dgplot)
```

* The **Residuals plot** looks OK, no systematic pattern.
* The **Q-Q plot** isn’t perfect, but I’m happy with the normality assumption.
* The **Location-Scale plot** is OK, some very slight suggestion of heterogeneity of variance, but nothing to be too worried about.
* The **Influential points plot** shows that all of the points are OK

:::

Woohoo!

## Dealing with interaction
If there _had been_ a significant interaction between the two predictor variables (for example, if light intensity had dropped off significantly faster in conifer woods than in broad leaf woods, in addition to being lower overall, then we would again be looking for two equations for the linear regression, but this time the gradients vary as well.
In this case interaction is important and so we need the output from a linear regression that explicitly includes the interaction term:

::: {.panel-tabset group="language"}
## tidyverse

```{r}
#| results: hide
lm(light ~ depth + species + depth:species,
   data = treelight)
```

or written using the short-hand:

```{r}
#| results: hide
lm(light ~ depth * species,
   data = treelight)
```

There really is absolutely no difference in the end result.
Either way this gives us the following output:

```{r}
#| echo: false
lm(light ~ depth * species,
   data = treelight)
```

As before the Broadleaf line is used as the baseline regression and we can read off the values for its intercept and slope directly:

Broadleaf:
\begin{equation}
Light = 7798.57 + -221.13 \times Depth
\end{equation}

Note that this is different from the previous section, by allowing for an interaction all fitted values will change.

For the conifer line we will have a different intercept value and a different gradient value. As before the value underneath `speciesConifer` gives us the difference between the intercept of the conifer line and the broad leaf line. The new, additional term `depth:speciesConifer` tells us how the coefficient of `depth` varies for the conifer line i.e. how the gradient is different. Putting these two together gives us the following equation for the regression line conifer woodland:

Conifer:
\begin{equation}
Light = (7798.57 + -2784.58) + (-221.13 + -71.04) \times Depth
\end{equation}

\begin{equation}
Light = 5014 + -292.2 \times Depth
\end{equation}

## R

```{r}
#| results: hide
lm(light ~ depth + species + depth:species,
   data = treelight_r)
```

or written using the short-hand:

```{r}
#| results: hide
lm(light ~ depth * species,
   data = treelight_r)
```

There really is absolutely no difference in the end result.
Either way this gives us the following output:

```{r}
#| echo: false
lm(light ~ depth * species,
   data = treelight_r)
```

As before the Broadleaf line is used as the baseline regression and we can read off the values for its intercept and slope directly:

Broadleaf:
\begin{equation}
Light = 7798.57 + -221.13 \times Depth
\end{equation}

Note that this is different from the previous section, by allowing for an interaction all fitted values will change.

For the conifer line we will have a different intercept value and a different gradient value. As before the value underneath `speciesConifer` gives us the difference between the intercept of the conifer line and the broad leaf line. The new, additional term `depth:speciesConifer` tells us how the coefficient of `depth` varies for the conifer line i.e. how the gradient is different. Putting these two together gives us the following equation for the regression line conifer woodland:

Conifer:
\begin{equation}
Light = (7798.57 + -2784.58) + (-221.13 + -71.04) \times Depth
\end{equation}

\begin{equation}
Light = 5014 + -292.2 \times Depth
\end{equation}

## Python

We've actually created this model before, but for clarity we'll define it here again.

```{python}
# create a linear model
model = smf.ols(formula = "light ~ depth * C(species)",
                data = treelight_py)

# and get the fitted parameters of the model
lm_treelight_py = model.fit()
```

We get the model parameters as follows:

```{python}
lm_treelight_py.summary()
```

As before the Broadleaf line is used as the baseline regression and we can read off the values for its intercept and slope directly:

Broadleaf:
\begin{equation}
Light = 7798.57 + -221.13 \times Depth
\end{equation}

Note that this is different from the previous section, by allowing for an interaction all fitted values will change.

For the conifer line we will have a different intercept value and a different gradient value. As before the value next to `C(species)[T.Conifer]` gives us the difference between the intercept of the conifer line and the broad leaf line. The interaction term `depth:C(species)[T.Conifer]` tells us how the coefficient of `depth` varies for the conifer line i.e. how the gradient is different. Putting these two together gives us the following equation for the regression line conifer woodland:

Conifer:
\begin{equation}
Light = (7798.57 + -2784.58) + (-221.13 + -71.04) \times Depth
\end{equation}

\begin{equation}
Light = 5014 + -292.2 \times Depth
\end{equation}
:::

## Exercise

::: {.callout-tip collapse="true"}
## Answer
::: {.panel-tabset group="language"}
## tidyverse
## R
## Python
:::
:::

## Key points

::: callout-note
-
-
-
:::
